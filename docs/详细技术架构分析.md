# FastGateway 内网穿透系统深度技术解析

## 目录
- [1. 系统概述](#1-系统概述)
- [2. 技术架构深度剖析](#2-技术架构深度剖析)
- [3. 核心组件详细分析](#3-核心组件详细分析)
- [4. 内网穿透实现原理](#4-内网穿透实现原理)
- [5. 通信协议深度解析](#5-通信协议深度解析)
- [6. 数据流转详细流程](#6-数据流转详细流程)
- [7. 安全机制实现细节](#7-安全机制实现细节)
- [8. 性能优化技术方案](#8-性能优化技术方案)

## 1. 系统概述

FastGateway 是一个企业级内网穿透解决方案，基于 .NET 8 和现代化微服务架构构建。该系统通过建立安全的双向隧道，实现内网服务的公网访问，支持多种协议和高并发场景。

### 1.1 系统架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                     互联网用户                               │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTPS/WSS 请求
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                FastGateway 服务端                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Gateway   │  │  Tunnels    │  │    Services         │  │
│  │   Router    │◄─┤  Manager    │◄─┤    & Auth          │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP/2 或 WebSocket 隧道
                      ▼
┌─────────────────────────────────────────────────────────────┐
│               TunnelClient 客户端                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ Monitor     │  │   YARP      │  │    Local            │  │
│  │ Server      │◄─┤   Proxy     │◄─┤    Services         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心技术栈

**服务端技术栈**:
- **.NET 8**: 现代化运行时，支持AOT和高性能
- **ASP.NET Core**: Web框架和中间件管道
- **Kestrel**: 高性能HTTP服务器
- **YARP**: Microsoft反向代理库
- **System.Threading.Channels**: 高性能异步通信

**客户端技术栈**:
- **.NET 8**: 统一运行时环境
- **HttpClient with HTTP/2**: 现代HTTP客户端
- **WebSocket**: 实时双向通信
- **YARP**: 本地服务代理
- **System.IO.Pipelines**: 高性能IO管道

## 2. 技术架构深度剖析

### 2.1 服务端架构详解

#### 2.1.1 主程序入口分析 (Program.cs)

```csharp
// 关键初始化代码分析
public static async Task Main(string[] args)
{
    // 1. 创建轻量级Web应用构建器
    var builder = WebApplication.CreateSlimBuilder(new WebApplicationOptions
    {
        ContentRootPath = AppContext.BaseDirectory,  // 设置内容根目录
        Args = args                                  // 传递命令行参数
    });

    // 2. 初始化核心配置
    FastGatewayOptions.Initialize(builder.Configuration);
    
    // 3. 配置JWT认证
    builder.Services
        .AddAuthentication(options => { 
            options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; 
        })
        .AddJwtBearer(options => {
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = false,           // 不验证发行者
                ValidateAudience = false,         // 不验证受众
                ValidateLifetime = true,          // 验证生命周期
                ValidateIssuerSigningKey = true,  // 验证签名密钥
                ClockSkew = TimeSpan.FromDays(jwtOptions.ExpireDay),
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.Secret))
            };
        });

    // 4. 注册核心服务
    builder.Services.AddHostedService<RenewSslBackgroundService>();  // SSL证书续期服务
    builder.Services.AddSingleton<ConfigurationService>();           // 配置管理服务
    
    var app = builder.Build();

    // 5. 启动网关实例
    using (var scope = app.Services.CreateScope())
    {
        var configService = scope.ServiceProvider.GetRequiredService<ConfigurationService>();
        
        // 并行启动所有配置的服务器
        foreach (var item in configService.GetServers())
        {
            await Task.Factory.StartNew(async () =>
                await Gateway.Gateway.BuilderGateway(item, 
                    configService.GetDomainNamesByServerId(item.Id),
                    blacklistAndWhitelists, rateLimits));
        }
    }
}
```

**关键技术点**:
1. **SlimBuilder模式**: 减少不必要的服务注册，提升启动性能
2. **并行网关启动**: 使用Task.Factory.StartNew并行创建多个网关实例
3. **作用域服务**: 确保配置服务的正确生命周期管理

#### 2.1.2 网关核心实现 (Gateway.cs)

```csharp
public static class Gateway
{
    // 网关实例管理 - 线程安全的并发字典
    private static readonly ConcurrentDictionary<string, WebApplication> GatewayWebApplications = new();
    
    // 静态代理目标配置
    private static readonly DestinationConfig StaticProxyDestination = new() { Address = "http://127.0.0.1" };

    /// <summary>
    /// 构建网关 - 为每个Server配置创建独立的网关实例
    /// </summary>
    public static async Task BuilderGateway(Server server, DomainName[] domainNames,
        List<BlacklistAndWhitelist> blacklistAndWhitelists, List<RateLimit> rateLimits)
    {
        if (!server.Enable) return;  // 跳过禁用的服务器

        var is80 = server.Listen == 80;
        if (is80) Has80Service = true;

        var builder = WebApplication.CreateBuilder();

        // 配置Kestrel服务器
        builder.WebHost.UseKestrel(options =>
        {
            if (server.IsHttps)
            {
                // HTTP重定向到HTTPS
                if (is80) options.Listen(IPAddress.Any, server.Listen);

                // HTTPS监听配置
                options.Listen(IPAddress.Any, is80 ? 443 : server.Listen, listenOptions =>
                {
                    Action<HttpsConnectionAdapterOptions> configure = adapterOptions =>
                    {
                        // 动态SSL证书选择器
                        adapterOptions.ServerCertificateSelector = ServerCertificateSelector;
                    };

                    if (is80) listenOptions.UseHttps(configure);
                    
                    // 支持HTTP/1.1, HTTP/2, HTTP/3
                    listenOptions.Protocols = HttpProtocols.Http1AndHttp2AndHttp3;
                });
            }
            else
            {
                options.Listen(IPAddress.Any, server.Listen);
            }

            // 移除请求体大小限制
            options.Limits.MaxRequestBodySize = null;
        });

        // WebSocket配置
        builder.Services.AddWebSockets(options =>
        {
            options.KeepAliveTimeout = TimeSpan.FromSeconds(120);
            options.AllowedOrigins.Add("*");  // 允许所有来源
        });

        // 构建路由和集群配置
        var (routes, clusters) = BuildConfig(domainNames);

        // 添加核心服务
        builder.Services.AddRateLimitService(rateLimits);  // 限流服务
        builder.Services.AddTunnel();                      // 隧道服务
        
        // YARP反向代理配置
        builder.Services
            .AddReverseProxy()
            .LoadFromMemory(routes, clusters)
            .AddGateway(server);

        var app = builder.Build();
        
        // 中间件管道配置
        app.UseCors("AllowAll");
        app.UseWebSockets();
        
        if (server.StaticCompress)
            app.UseResponseCompression();

        // ACME Challenge支持 (Let's Encrypt)
        if (is80)
        {
            app.Use(async (context, next) =>
            {
                if (context.Request.Path.StartsWithSegments("/.well-known/acme-challenge", out var token))
                    await CertService.Challenge(context, token.Value![1..]);
                else
                    await next.Invoke();
            });
        }

        // 核心中间件
        app.UseInitGatewayMiddleware();         // 初始化中间件
        app.UseRateLimitMiddleware(rateLimits); // 限流中间件
        
        if (server.EnableBlacklist || server.EnableWhitelist) 
            app.UseBlacklistMiddleware(blacklistAndWhitelists); // 访问控制

        // 隧道注册端点
        app.Use(async (context, next) =>
        {
            if (context.Request.Path == "/internal/gateway/Server/register")
            {
                await HandleTunnelRegistration(context);
                return;
            }
            await next(context);
        });
        
        // 隧道管理端点
        app.Map("/internal/gateway/Server", builder =>
        {
            builder.UseMiddleware<AgentManagerMiddleware>();
            builder.UseMiddleware<AgentManagerTunnelMiddleware>();
        });

        app.MapReverseProxy();  // 映射反向代理

        // 注册网关实例
        GatewayWebApplications.TryAdd(server.Id, app);
        
        // 生命周期管理
        app.Lifetime.ApplicationStopping.Register(() => { 
            GatewayWebApplications.Remove(server.Id, out _); 
        });

        await app.RunAsync();
    }
}
```

**关键技术特性**:

1. **多实例架构**: 每个Server配置对应一个独立的WebApplication实例
2. **动态SSL**: `ServerCertificateSelector`实现SNI支持
3. **协议栈支持**: HTTP/1.1, HTTP/2, HTTP/3 全栈支持
4. **中间件管道**: 精心设计的请求处理管道

#### 2.1.3 路由配置构建 (BuildConfig方法)

```csharp
private static (IReadOnlyList<RouteConfig> routes, IReadOnlyList<ClusterConfig> clusters) BuildConfig(
    DomainName[] domainNames)
{
    var routes = new List<RouteConfig>();
    var clusters = new List<ClusterConfig>();

    foreach (var domainName in domainNames)
    {
        // 路径标准化处理
        var path = domainName.Path ?? string.Empty;
        if (string.IsNullOrWhiteSpace(path))
            path = "/{**catch-all}";           // 捕获所有路径
        else if (path == "/")
            path = "/{**catch-all}";
        else
            path = $"/{path.TrimStart('/')}/{{**catch-all}}";  // 规范化路径

        // 根据服务类型创建不同配置
        switch (domainName.ServiceType)
        {
            case ServiceType.Service:
                // 单一服务配置
                var config = new DestinationConfig
                {
                    Address = domainName.Service,
                    Host = domainName.Host  // 可选的Host头重写
                };
                
                var cluster = new ClusterConfig
                {
                    ClusterId = domainName.Id,
                    Destinations = new Dictionary<string, DestinationConfig>
                    {
                        { Guid.NewGuid().ToString("N"), config }
                    }
                };
                clusters.Add(cluster);
                break;

            case ServiceType.ServiceCluster:
                // 负载均衡集群配置
                var destinations = domainName.UpStreams.Select(x => new DestinationConfig
                {
                    Address = x.Service
                }).ToDictionary(x => Guid.NewGuid().ToString("N"));

                var clusterConfig = new ClusterConfig
                {
                    ClusterId = domainName.Id,
                    Destinations = destinations
                };
                clusters.Add(clusterConfig);
                break;

            case ServiceType.StaticFile:
                // 静态文件服务配置
                var staticCluster = new ClusterConfig
                {
                    ClusterId = domainName.Id,
                    Destinations = new Dictionary<string, DestinationConfig>
                    {
                        { Guid.NewGuid().ToString("N"), StaticProxyDestination }
                    },
                    Metadata = CreateTryFilesMetadata(domainName.TryFiles)
                };
                clusters.Add(staticCluster);
                break;
        }

        // 创建路由配置
        var route = new RouteConfig
        {
            RouteId = domainName.Id,
            ClusterId = domainName.Id,
            Match = new RouteMatch
            {
                Hosts = domainName.Domains,  // 域名匹配规则
                Path = path                  // 路径匹配规则
            },
            Metadata = CreateRouteMetadata(domainName)
        };

        routes.Add(route);
    }

    return (routes, clusters);
}
```

### 2.2 客户端架构详解

#### 2.2.1 客户端启动流程 (Program.cs)

```csharp
// 读取配置文件
if (args.Length > 0 && args[0].StartsWith("-c", StringComparison.OrdinalIgnoreCase))
{
    var configFilePath = args[0][2..].Trim();
    if (!string.IsNullOrEmpty(configFilePath) && File.Exists(configFilePath))
    {
        builder.Configuration.AddJsonFile(configFilePath, optional: false, reloadOnChange: true);
    }
    else
    {
        Console.WriteLine("配置文件不存在或路径错误: " + configFilePath);
        return;
    }
}

// Windows服务支持
if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
{
    builder.Services.AddWindowsService();
}

// 从Tunnel配置生成YARP配置
var (routeConfigs, clusterConfigs) = Tunnel.ToYarpOption();

// 配置反向代理
builder.Services.AddReverseProxy()
    .LoadFromMemory(routeConfigs, clusterConfigs);

// 注册后台服务
builder.Services.AddHostedService<Worker>();

var app = builder.Build();

// 映射反向代理并启动
app.MapReverseProxy();
await app.RunAsync("http://localhost:" + Tunnel.GetTunnel().Port);
```

#### 2.2.2 Worker服务实现 (Worker.cs)

```csharp
public class Worker : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var tunnel = Tunnel.GetTunnel();
        
        // 创建监控服务和服务器客户端
        var monitorServer = new MonitorServer(_services);
        var serverClient = new ServerClient(monitorServer, tunnel, _logger);

        // 注册节点到服务端
        await monitorServer.RegisterNodeAsync(tunnel, stoppingToken);

        // 主循环 - 保持连接和自动重连
        while (!stoppingToken.IsCancellationRequested)
        {
            await MonitorServerAsync(serverClient, tunnel, stoppingToken);
            _logger.LogInformation("尝试重新连接到服务器...");
            await Task.Delay(tunnel.ReconnectInterval, stoppingToken);
            _logger.LogInformation("重新连接到服务器中...");
        }
    }

    private async Task MonitorServerAsync(ServerClient serverClient, Tunnel tunnel, CancellationToken stoppingToken)
    {
        try
        {
            await serverClient.TransportCoreAsync(tunnel, stoppingToken);
        }
        catch (UnauthorizedAccessException e)
        {
            _logger.LogError(e, "连接被拒绝，请检查Token是否正确或是否过期！");
            Environment.Exit(0);  // 认证失败直接退出
        }
        catch (Exception e)
        {
            _logger.LogError(e, "连接错误！");
            await Task.Delay(1000, stoppingToken);
        }
    }
}
```

## 3. 核心组件详细分析

### 3.1 隧道管理系统

#### 3.1.1 AgentManagerMiddleware - 节点连接管理

```csharp
internal class AgentManagerMiddleware : IMiddleware
{
    private readonly string TunnelToken = configuration["TunnelToken"] ?? "Aa123456.";

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // 1. 创建传输特性并验证协议
        var feature = new FastFeature(context);
        if (!IsAllowProtocol(feature.Protocol))
        {
            context.Response.StatusCode = StatusCodes.Status405MethodNotAllowed;
            return;
        }

        context.Features.Set<IFastFeature>(feature);

        // 2. 提取节点名称和Token
        var nodeName = context.Request.Query["nodeName"].ToString();
        var token = context.Request.Query["token"].ToString();

        // 3. Token验证 (带延迟防暴力破解)
        if (string.IsNullOrEmpty(token) || TunnelToken != token)
        {
            await Task.Delay(5000);  // 5秒延迟
            context.Response.StatusCode = StatusCodes.Status401Unauthorized;
            return;
        }

        // 4. 建立主连接
        var host = "node_" + nodeName;
        try
        {
            // 创建安全写入流
            var stream = await feature.AcceptAsSafeWriteStreamAsync();
            
            // 创建客户端连接对象
            var connection = new AgentClientConnection(host, stream, new ConnectionConfig(), logger);
            
            // 创建并管理客户端
            await using var client = new AgentClient(connection, agentTunnelFactory, context);
            if (await agentClientManager.AddAsync(client, default))
            {
                // 等待连接关闭
                await connection.WaitForCloseAsync();
                await agentClientManager.RemoveAsync(client, default);
            }
        }
        catch (Exception e)
        {
            logger.LogError(e, "Failed to create client connection.");
        }
        finally
        {
            // 清理资源
            await tunnelClientProxy.RemoveClientAsync(nodeName);
        }
    }

    // 验证允许的协议类型
    private static bool IsAllowProtocol(TransportProtocol protocol)
    {
        return protocol is TransportProtocol.Http11 
                        or TransportProtocol.Http2 
                        or TransportProtocol.WebSocketWithHttp11
                        or TransportProtocol.WebSocketWithHttp2;
    }
}
```

#### 3.1.2 AgentClientConnection - 客户端连接实现

```csharp
public sealed partial class AgentClientConnection : IAsyncDisposable
{
    private const string Ping = "PING";
    private const string Pong = "PONG";
    private static readonly ReadOnlyMemory<byte> PingLine = "PING\r\n"u8.ToArray();
    private static readonly ReadOnlyMemory<byte> PongLine = "PONG\r\n"u8.ToArray();

    private readonly Stream _stream;
    private readonly TimeSpan _keepAliveTimeout;
    private readonly Timer? _keepAliveTimer;
    private int _httpTunnelCount;

    public AgentClientConnection(string clientId, Stream stream, ConnectionConfig config, ILogger logger)
    {
        ClientId = clientId;
        _stream = stream;
        _logger = logger;

        // 配置心跳机制
        var keepAliveInterval = config.KeepAliveInterval;
        if (config.KeepAlive && keepAliveInterval > TimeSpan.Zero)
        {
            _keepAliveTimeout = keepAliveInterval.Add(TimeSpan.FromSeconds(10d));
            _keepAliveTimer = new Timer(KeepAliveTimerTick, null, keepAliveInterval, keepAliveInterval);
        }
    }

    // 心跳定时器
    private async void KeepAliveTimerTick(object? state)
    {
        try
        {
            await _stream.WriteAsync(PingLine);
            Log.LogSendPing(_logger, ClientId);
        }
        catch (Exception)
        {
            _keepAliveTimer?.Dispose();
        }
    }

    // 创建HTTP隧道
    public async Task CreateHttpTunnelAsync(Guid tunnelId, CancellationToken cancellationToken)
    {
        const int size = 64;
        var tunnelIdLine = $"{tunnelId}\r\n";

        // 使用内存池减少分配
        using var owner = MemoryPool<byte>.Shared.Rent(size);
        var length = Encoding.ASCII.GetBytes(tunnelIdLine, owner.Memory.Span);

        var buffer = owner.Memory[..length];
        await _stream.WriteAsync(buffer, cancellationToken);
    }

    // 连接处理主循环
    private async Task HandleConnectionAsync(CancellationToken cancellationToken)
    {
        using var textReader = new StreamReader(_stream, bufferSize: 8, leaveOpen: true);
        
        while (!cancellationToken.IsCancellationRequested)
        {
            var textTask = textReader.ReadLineAsync(cancellationToken);
            var text = _keepAliveTimeout <= TimeSpan.Zero
                ? await textTask
                : await textTask.AsTask().WaitAsync(_keepAliveTimeout, cancellationToken);

            switch (text)
            {
                case null:
                    return;  // 连接关闭

                case Ping:
                    Log.LogRecvPing(_logger, ClientId);
                    await _stream.WriteAsync(PongLine, cancellationToken);
                    break;

                case Pong:
                    Log.LogRecvPong(_logger, ClientId);
                    break;

                default:
                    Log.LogRecvUnknown(_logger, ClientId, text);
                    break;
            }
        }
    }

    // 隧道计数管理
    public int IncrementHttpTunnelCount() => Interlocked.Increment(ref _httpTunnelCount);
    public int DecrementHttpTunnelCount() => Interlocked.Decrement(ref _httpTunnelCount);
}
```

#### 3.1.3 HttpTunnel - HTTP隧道实现

```csharp
public sealed partial class HttpTunnel : DelegatingStream
{
    private readonly TaskCompletionSource _closeTaskCompletionSource = new();
    private readonly long _tickCout = Environment.TickCount64;
    private AgentClientConnection? _connection;

    public HttpTunnel(Stream inner, Guid tunnelId, TransportProtocol protocol, ILogger logger)
        : base(inner)
    {
        Id = tunnelId;
        Protocol = protocol;
    }

    public Task Closed => _closeTaskCompletionSource.Task;
    public Guid Id { get; }
    public TransportProtocol Protocol { get; }

    // 绑定到客户端连接
    public void BindConnection(AgentClientConnection connection)
    {
        _connection = connection;
    }

    // 异步释放资源
    public override ValueTask DisposeAsync()
    {
        SetClosedResult();
        return Inner.DisposeAsync();
    }

    // 同步释放资源
    protected override void Dispose(bool disposing)
    {
        SetClosedResult();
        Inner.Dispose();
    }

    // 设置关闭结果和记录日志
    private void SetClosedResult()
    {
        if (_closeTaskCompletionSource.TrySetResult())
        {
            var httpTunnelCount = _connection?.DecrementHttpTunnelCount();
            var lifeTime = TimeSpan.FromMilliseconds(Environment.TickCount64 - _tickCout);
            
            Log.LogTunnelClosed(logger, _connection?.ClientId, Protocol, Id, 
                               lifeTime, httpTunnelCount);
        }
    }
}
```

### 3.2 客户端连接管理

#### 3.2.1 MonitorServer - 服务器连接管理

```csharp
public class MonitorServer
{
    private readonly HttpMessageInvoker _httpClient = new(CreateDefaultHttpHandler(), true);

    // 创建优化的HTTP处理器
    private static SocketsHttpHandler CreateDefaultHttpHandler()
    {
        return new SocketsHttpHandler
        {
            EnableMultipleHttp2Connections = true,  // 允许多个HTTP/2连接
            ConnectTimeout = TimeSpan.FromSeconds(60),
            SslOptions = new SslClientAuthenticationOptions
            {
                // 跳过证书验证（用于开发环境）
                RemoteCertificateValidationCallback = (_, _, _, _) => true
            }
        };
    }

    // 创建到本地服务的连接
    public async Task<Stream> CreateTargetTunnelAsync(Tunnel tunnel, CancellationToken cancellationToken)
    {
        var socket = new Socket(SocketType.Stream, ProtocolType.Tcp) { NoDelay = true };

        try
        {
            EndPoint endPoint = new DnsEndPoint("localhost", tunnel.Port);
            await socket.ConnectAsync(endPoint, cancellationToken);
            return new NetworkStream(socket);
        }
        catch (Exception ex)
        {
            socket.Dispose();
            throw;
        }
    }

    // HTTP/2连接实现
    private async Task<Stream> Http20ConnectServerAsync(Tunnel? tunnel, Guid? tunnelId, CancellationToken cancellationToken)
    {
        Uri serverUri;
        if (tunnelId == null)
        {
            // 主连接URL
            serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?nodeName={tunnel.Name}&token={tunnel?.Token}");
        }
        else
        {
            // 隧道连接URL
            serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?tunnelId={tunnelId}");
        }

        // 配置HTTP/2 CONNECT请求
        var request = new HttpRequestMessage(HttpMethod.Connect, serverUri);
        request.Headers.Protocol = Constant.Protocol;        // 设置协议头
        request.Version = HttpVersion.Version20;              // 强制HTTP/2
        request.VersionPolicy = HttpVersionPolicy.RequestVersionExact;

        // 发送请求并获取流
        using var timeoutTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(60));
        using var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(timeoutTokenSource.Token, cancellationToken);

        var httpResponse = await _httpClient.SendAsync(request, linkedTokenSource.Token);

        if (httpResponse.StatusCode == HttpStatusCode.Unauthorized)
        {
            throw new UnauthorizedAccessException("未授权,请检查token是否正确");
        }

        // 返回HTTP/2流
        return await httpResponse.Content.ReadAsStreamAsync(linkedTokenSource.Token);
    }

    // WebSocket连接实现
    private async Task<Stream> HttpWebSocketConnectServerAsync(Tunnel? tunnel, Guid? tunnelId, CancellationToken cancellationToken)
    {
        Uri serverUri;
        if (tunnelId == null)
        {
            serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?nodeName={tunnel.Name}&token={tunnel?.Token}");
        }
        else
        {
            serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?tunnelId={tunnelId}");
        }

        var webSocket = new ClientWebSocket();
        webSocket.Options.AddSubProtocol(Constant.Protocol);

        // 配置HTTP版本策略
        if (tunnel?.ServerHttp2Support != false && serverUri.Scheme == Uri.UriSchemeWss)
        {
            webSocket.Options.HttpVersion = HttpVersion.Version20;
            webSocket.Options.HttpVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
        }
        else
        {
            webSocket.Options.HttpVersion = HttpVersion.Version11;
            webSocket.Options.HttpVersionPolicy = HttpVersionPolicy.RequestVersionExact;
        }

        // 设置请求头
        if (tunnelId == null)
        {
            webSocket.Options.SetRequestHeader("nodeName", tunnel?.Name ?? string.Empty);
            webSocket.Options.SetRequestHeader("token", tunnel?.Token ?? string.Empty);
            webSocket.Options.SetRequestHeader("clientType", "TunnelClient");
            webSocket.Options.SetRequestHeader("requestId", Guid.NewGuid().ToString());
        }

        try
        {
            await webSocket.ConnectAsync(serverUri, _httpClient, cancellationToken);
            return new WebSocketStream(webSocket);
        }
        catch (Exception)
        {
            webSocket.Dispose();
            throw;
        }
    }

    // 节点注册
    public async Task RegisterNodeAsync(Tunnel tunnel, CancellationToken cancellationToken)
    {
        using var httpClient = new HttpClient();

        var serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server/register?token={tunnel.Token}");

        var jsonContent = new StringContent(JsonSerializer.Serialize(tunnel, AppContext.Default.Options), 
                                          Encoding.UTF8, "application/json");

        var response = await httpClient.PostAsync(serverUri, jsonContent, cancellationToken);

        if (response.StatusCode == HttpStatusCode.Unauthorized)
        {
            throw new UnauthorizedAccessException("未授权,请检查token是否正确");
        }

        if (!response.IsSuccessStatusCode)
        {
            var error = await response.Content.ReadAsStringAsync(cancellationToken);
            throw new InvalidOperationException($"注册节点失败: {error}");
        }
    }
}
```

#### 3.2.2 ServerClient - 服务器客户端

```csharp
public class ServerClient : IDisposable
{
    private int _tunnelCount;

    public async Task TransportCoreAsync(Tunnel tunnel, CancellationToken cancellationToken)
    {
        // 创建主连接
        await using var connection = await monitorServer.CreateServerConnectionAsync(tunnel, cancellationToken);

        try
        {
            using var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, cancellationToken);
            
            // 监听隧道ID并处理
            await foreach (var tunnelId in connection.ReadTunnelIdAsync(cancellationToken))
            {
                BindTunnelIoAsync(tunnelId, linkedTokenSource.Token);
            }
        }
        catch (Exception ex)
        {
            logger.LogError("连接错误！" + ex.Message);
        }
    }

    // 绑定隧道IO - 核心数据转发逻辑
    private async void BindTunnelIoAsync(Guid tunnelId, CancellationToken cancellationToken)
    {
        var stopwatch = Stopwatch.StartNew();
        try
        {
            // 创建到本地服务的连接
            await using var targetTunnel = await monitorServer.CreateTargetTunnelAsync(tunnel, cancellationToken);

            // 创建到服务器的隧道
            await using var serverTunnel = await monitorServer.CreateServerTunnelAsync(tunnel, tunnelId, cancellationToken);

            var count = Interlocked.Increment(ref _tunnelCount);
            logger.LogWarning("新的隧道id，耗时：" + stopwatch.ElapsedMilliseconds + "ms" + " 当前数量：" + count);

            // 双向数据复制 - 这是核心的数据转发逻辑
            var server2Target = serverTunnel.CopyToAsync(targetTunnel, cancellationToken);
            var target2Server = targetTunnel.CopyToAsync(serverTunnel, cancellationToken);
            
            // 等待任一方向的传输完成
            var task = await Task.WhenAny(server2Target, target2Server);
        }
        catch (OperationCanceledException operationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            logger.LogWarning("错误：" + operationCanceledException.Message);
        }
        catch (Exception ex)
        {
            logger.LogError("连接异常：" + ex.Message);
        }
        finally
        {
            stopwatch.Stop();
            Interlocked.Decrement(ref _tunnelCount);
        }
    }
}
```

### 3.3 配置管理系统

#### 3.3.1 Tunnel配置模型

```csharp
public class Tunnel
{
    public int Port { get; set; }                    // 本地监听端口
    public string Token { get; set; }                // 认证令牌
    public string Type { get; set; }                 // 连接类型: "h2" 或 "ws"
    public bool ServerHttp2Support { get; set; }     // 服务器HTTP/2支持
    public string ServerUrl { get; set; }            // 服务器地址
    public string Name { get; set; }                 // 节点名称
    public int ReconnectInterval { get; set; }       // 重连间隔(秒)
    public int HeartbeatInterval { get; set; }       // 心跳间隔(秒)
    public TunnelProxy[] Proxy { get; set; }         // 代理配置数组

    // 协议类型判断
    public bool IsHttp2 => Type.Equals("h2", StringComparison.OrdinalIgnoreCase);
    public bool IsWebSocket => Type.Equals("ws", StringComparison.OrdinalIgnoreCase);

    // 从配置文件加载
    public static Tunnel GetTunnel()
    {
        var path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "tunnel.json");
        var json = File.ReadAllText(path);
        return JsonSerializer.Deserialize<Tunnel>(json, AppContext.JsonOptions);
    }

    // 转换为YARP配置
    public static (IReadOnlyList<RouteConfig> routes, IReadOnlyList<ClusterConfig> clusters) ToYarpOption()
    {
        var routes = new List<RouteConfig>();
        var clusters = new List<ClusterConfig>();
        var tunnel = GetTunnel();

        foreach (var proxy in tunnel.Proxy)
        {
            var routeId = Guid.NewGuid().ToString("N");
            var clusterId = Guid.NewGuid().ToString("N");

            // 路径标准化
            var path = proxy.Route ?? string.Empty;
            if (string.IsNullOrWhiteSpace(path))
                path = "/{**catch-all}";
            else if (path == "/")
                path = "/{**catch-all}";
            else
                path = $"/{path.TrimStart('/')}/{{**catch-all}}";

            // 创建路由配置
            var route = new RouteConfig
            {
                RouteId = routeId,
                ClusterId = clusterId,
                Match = new RouteMatch
                {
                    Path = path,
                    Hosts = proxy.Domains  // 域名匹配
                }
            };

            // 创建目标配置
            DestinationConfig config;
            if (!string.IsNullOrEmpty(proxy.Host))
            {
                config = new DestinationConfig
                {
                    Address = proxy.LocalRemote,
                    Host = proxy.Host  // Host头重写
                };
            }
            else
            {
                config = new DestinationConfig
                {
                    Address = proxy.LocalRemote
                };
            }

            // 创建集群配置
            var cluster = new ClusterConfig
            {
                ClusterId = clusterId,
                Destinations = new Dictionary<string, DestinationConfig>
                {
                    { Guid.NewGuid().ToString("N"), config }
                }
            };

            clusters.Add(cluster);
            routes.Add(route);
        }

        return (routes, clusters);
    }

    // 配置验证
    public void Validate()
    {
        if (string.IsNullOrEmpty(Token))
            throw new ArgumentException("Token cannot be null or empty.");

        if (string.IsNullOrEmpty(ServerUrl))
            throw new ArgumentException("ServerUrl cannot be null or empty.");

        if (ReconnectInterval <= 0) ReconnectInterval = 5;
        if (HeartbeatInterval <= 0) HeartbeatInterval = 30;

        if (Proxy == null || Proxy.Length == 0)
            throw new ArgumentException("At least one proxy configuration is required.");

        foreach (var proxy in Proxy)
        {
            if (string.IsNullOrEmpty(proxy.Route))
                throw new ArgumentException("Proxy Route cannot be null or empty.");

            if (string.IsNullOrEmpty(proxy.LocalRemote))
                throw new ArgumentException("Proxy LocalRemote cannot be null or empty.");

            if (!proxy.Route.StartsWith("/"))
                throw new ArgumentException("Proxy Route must start with a '/' character.");

            if (!proxy.LocalRemote.StartsWith("http://") && !proxy.LocalRemote.StartsWith("https://") &&
                !proxy.LocalRemote.StartsWith("ws://") && !proxy.LocalRemote.StartsWith("wss://"))
            {
                throw new ArgumentException("Proxy LocalRemote must start with 'http://', 'https://', 'ws://', or 'wss://'.");
            }
        }
    }

    // 代理配置子类
    public class TunnelProxy
    {
        public string? Host { get; set; }              // Host头重写
        public string[] Domains { get; set; }          // 匹配的域名
        public string Route { get; set; }              // 路由路径
        public string LocalRemote { get; set; }        // 本地服务地址
        public string Description { get; set; }        // 描述信息
        public bool Enabled { get; set; }              // 是否启用
    }
}
```

## 4. 内网穿透实现原理

### 4.1 连接建立流程图

```
客户端启动流程:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   TunnelClient  │    │   MonitorServer │    │   FastGateway   │
│     启动        │    │                 │    │     服务端      │
└────────┬────────┘    └─────────────────┘    └─────────────────┘
         │
         ▼
┌─────────────────┐
│  加载tunnel.json │
│  配置文件        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐    ┌─────────────────┐
│   创建YARP      │───▶│   启动本地代理   │
│   反向代理配置   │    │   监听端口      │
└────────┬────────┘    └─────────────────┘
         │
         ▼
┌─────────────────┐
│   注册节点到    │
│   服务器        │────┐
└────────┬────────┘    │
         │             ▼
         │    ┌─────────────────┐
         │    │ POST /internal/ │
         │    │ gateway/Server/ │
         │    │ register        │
         │    └────────┬────────┘
         │             │
         │             ▼
         │    ┌─────────────────┐
         │    │  验证Token并    │
         │    │  保存配置       │
         │    └─────────────────┘
         │
         ▼
┌─────────────────┐
│   建立主连接    │
│ (HTTP/2 CONNECT │────┐
│  或 WebSocket)  │    │
└────────┬────────┘    │
         │             ▼
         │    ┌─────────────────┐
         │    │   创建Agent     │
         │    │ ClientConnection│
         │    └────────┬────────┘
         │             │
         │             ▼
         │    ┌─────────────────┐
         │    │   启动心跳      │
         │    │   保活机制      │
         │    └─────────────────┘
         │
         ▼
┌─────────────────┐
│   进入监听      │
│   隧道ID循环    │
└─────────────────┘
```

### 4.2 请求处理流程图

```
外部请求处理流程:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   外部客户端    │    │   FastGateway   │    │  TunnelClient   │    │   内网服务      │
│                │    │     服务端      │    │                │    │                │
└────────┬────────┘    └─────────────────┘    └─────────────────┘    └─────────────────┘
         │
         ▼ HTTPS请求
┌─────────────────┐
│ 1. DNS解析到    │
│    公网服务器   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐    ┌─────────────────┐
│ 2. 请求到达     │───▶│ 3. 路由匹配     │
│    Gateway      │    │    查找对应的   │
└─────────────────┘    │    TunnelClient │
                       └────────┬────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │ 4. 生成隧道ID   │
                       │    UUID         │
                       └────────┬────────┘
                                │
                                ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │ 5. 通过主连接   │───▶│ 6. 客户端接收   │
                       │    发送隧道ID   │    │    隧道ID       │
                       └─────────────────┘    └────────┬────────┘
                                                       │
                                                       ▼
                                              ┌─────────────────┐
                                              │ 7. 创建到服务器 │
                                              │    的隧道连接   │
                                              └────────┬────────┘
                                                       │
                                                       ▼
                                              ┌─────────────────┐    ┌─────────────────┐
                                              │ 8. 连接到本地   │───▶│ 9. 建立到内网   │
                                              │    代理端口     │    │    服务的连接   │
                                              └─────────────────┘    └────────┬────────┘
                                                                              │
                                                                              ▼
                       ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
                       │ 12. 响应数据    │◄───│ 11. 双向数据    │◄───│ 10. 处理请求    │
                       │     返回外部    │    │     转发        │    │     生成响应    │
                       └────────┬────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
┌─────────────────┐    ┌─────────────────┐
│ 13. 客户端接收  │◄───│     通过隧道    │
│     响应数据    │    │     返回响应    │
└─────────────────┘    └─────────────────┘
```

### 4.3 隧道创建时序图

```
隧道创建详细时序:

外部客户端    FastGateway    AgentClient    TunnelClient    内网服务
    │             │              │              │             │
    │ HTTP请求     │              │              │             │
    ├─────────────▶│              │              │             │
    │             │              │              │             │
    │             │ 路由解析      │              │             │
    │             │─────────────┐ │              │             │
    │             │◄────────────┘ │              │             │
    │             │              │              │             │
    │             │ 生成tunnelId  │              │             │
    │             │─────────────┐ │              │             │
    │             │◄────────────┘ │              │             │
    │             │              │              │             │
    │             │ 发送tunnelId  │              │             │
    │             ├──────────────▶│              │             │
    │             │              │              │             │
    │             │              │ 通知客户端    │             │
    │             │              ├──────────────▶│             │
    │             │              │              │             │
    │             │              │              │ 连接本地端口│
    │             │              │              ├─────────────▶│
    │             │              │              │             │
    │             │              │              │ 连接成功    │
    │             │              │              │◄────────────┤
    │             │              │              │             │
    │             │              │ 创建服务器隧道│             │
    │             │              │◄─────────────┤             │
    │             │              │              │             │
    │             │ 隧道建立完成  │              │             │
    │             │◄─────────────┤              │             │
    │             │              │              │             │
    │ 开始数据传输 │              │              │             │
    ├─────────────▶│─────────────▶│─────────────▶│─────────────▶│
    │             │              │              │             │
    │ 响应数据     │              │              │             │
    │◄─────────────│◄─────────────│◄─────────────│◄─────────────┤
    │             │              │              │             │
```

### 4.4 心跳保活机制

```csharp
心跳协议实现:

服务端 (AgentClientConnection):
┌─────────────────┐
│   Timer触发     │
│   发送"PING\r\n"│
└────────┬────────┘
         │
         ▼
┌─────────────────┐    ┌─────────────────┐
│   等待响应      │───▶│   接收"PONG\r\n"│
│   (超时10秒)    │    │   保持连接活跃  │
└─────────────────┘    └─────────────────┘

客户端 (ServerConnection):
┌─────────────────┐
│  接收"PING\r\n" │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  发送"PONG\r\n" │
│  确认连接活跃   │
└─────────────────┘

双向心跳检测:
private async void KeepAliveTimerTick(object? state)
{
    try
    {
        await _stream.WriteAsync(PingLine);
        Log.LogSendPing(_logger, ClientId);
    }
    catch (Exception)
    {
        // 发送失败，连接已断开
        _keepAliveTimer?.Dispose();
    }
}

// 读取循环中的心跳处理
switch (text)
{
    case Ping:
        Log.LogRecvPing(_logger, ClientId);
        await _stream.WriteAsync(PongLine, cancellationToken);
        break;
        
    case Pong:
        Log.LogRecvPong(_logger, ClientId);
        // 确认服务端仍然活跃
        break;
}
```

## 5. 通信协议深度解析

### 5.1 HTTP/2 CONNECT协议实现

#### 5.1.1 服务端HTTP/2处理

```csharp
// 在TunnelMiddleware中处理HTTP/2隧道
public class TunnelMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var requiredFeature = context.Features.GetRequiredFeature<IFastFeature>();
        
        // 检查是否为隧道请求
        if (!requiredFeature.IsRequest)
        {
            await next(context);
            return;
        }

        // 提取隧道ID
        if (!Guid.TryParse(context.Request.Query["tunnelId"].ToString(), out var tunnelId))
        {
            await next(context);
            return;
        }

        // 检查隧道工厂中是否存在等待的隧道
        if (httpTunnelFactory.Contains(tunnelId))
        {
            // 接受为流连接
            var stream = await requiredFeature.AcceptAsStreamAsync();

            // 创建HTTP隧道对象
            var httpTunnel = new HttpTunnel(stream, tunnelId, requiredFeature.Protocol, logger);

            // 设置隧道结果并等待关闭
            if (httpTunnelFactory.SetResult(httpTunnel))
                await httpTunnel.Closed;
            else
                httpTunnel.Dispose();
        }
    }
}

// FastFeature实现HTTP/2流接受
public class FastFeature : IFastFeature
{
    private readonly HttpContext _httpContext;

    public bool IsRequest => _httpContext.Request.Method == HttpMethods.Connect;
    
    public TransportProtocol Protocol
    {
        get
        {
            var protocol = _httpContext.Request.Protocol;
            return protocol switch
            {
                "HTTP/1.1" => TransportProtocol.Http11,
                "HTTP/2" => TransportProtocol.Http2,
                _ => TransportProtocol.Http11
            };
        }
    }

    // 接受HTTP/2流
    public async ValueTask<Stream> AcceptAsStreamAsync()
    {
        var feature = _httpContext.Features.GetRequiredFeature<IHttpRequestBodyDetectionFeature>();
        if (feature.CanHaveBody)
        {
            return _httpContext.Request.Body;
        }

        // 对于CONNECT请求，直接返回响应体流
        _httpContext.Response.StatusCode = 200;
        await _httpContext.Response.Body.FlushAsync();
        
        return new DuplexHttpStream(_httpContext);
    }
}
```

#### 5.1.2 客户端HTTP/2 CONNECT实现

```csharp
// MonitorServer中的HTTP/2连接实现
private async Task<Stream> Http20ConnectServerAsync(Tunnel? tunnel, Guid? tunnelId, CancellationToken cancellationToken)
{
    Uri serverUri;
    if (tunnelId == null)
    {
        // 主连接：注册节点
        serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?nodeName={tunnel.Name}&token={tunnel?.Token}");
    }
    else
    {
        // 隧道连接：特定隧道ID
        serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?tunnelId={tunnelId}");
    }

    // 创建HTTP/2 CONNECT请求
    var request = new HttpRequestMessage(HttpMethod.Connect, serverUri);
    
    // 设置关键头部
    request.Headers.Protocol = Constant.Protocol;  // "tunneling-proto"
    request.Version = HttpVersion.Version20;        // 强制使用HTTP/2
    request.VersionPolicy = HttpVersionPolicy.RequestVersionExact;  // 严格版本匹配

    // 配置超时
    using var timeoutTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(60));
    using var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(timeoutTokenSource.Token, cancellationToken);

    // 发送CONNECT请求
    var httpResponse = await _httpClient.SendAsync(request, linkedTokenSource.Token);

    // 检查认证
    if (httpResponse.StatusCode == HttpStatusCode.Unauthorized)
    {
        Log.UnauthorizedAccess(_logger);
        throw new UnauthorizedAccessException("未授权,请检查token是否正确");
    }

    // 返回HTTP/2流用于双向通信
    return await httpResponse.Content.ReadAsStreamAsync(linkedTokenSource.Token);
}

// SocketsHttpHandler配置优化
private static SocketsHttpHandler CreateDefaultHttpHandler()
{
    return new SocketsHttpHandler
    {
        // 关键配置：允许多个HTTP/2连接
        EnableMultipleHttp2Connections = true,
        
        // 连接超时设置
        ConnectTimeout = TimeSpan.FromSeconds(60),
        
        // SSL配置（开发环境跳过证书验证）
        SslOptions = new SslClientAuthenticationOptions
        {
            RemoteCertificateValidationCallback = (_, _, _, _) => true
        }
    };
}
```

### 5.2 WebSocket协议实现

#### 5.2.1 客户端WebSocket连接

```csharp
private async Task<Stream> HttpWebSocketConnectServerAsync(Tunnel? tunnel, Guid? tunnelId, CancellationToken cancellationToken)
{
    Uri serverUri;
    if (tunnelId == null)
    {
        // 主连接WebSocket URL
        serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?nodeName={tunnel.Name}&token={tunnel?.Token}");
    }
    else
    {
        // 隧道WebSocket URL
        serverUri = new Uri($"{tunnel.ServerUrl.TrimEnd('/')}/internal/gateway/Server?tunnelId={tunnelId}");
    }

    var webSocket = new ClientWebSocket();
    
    // 设置子协议
    webSocket.Options.AddSubProtocol(Constant.Protocol);

    // HTTP版本策略配置
    if (tunnel?.ServerHttp2Support != false && serverUri.Scheme == Uri.UriSchemeWss)
    {
        // 支持HTTP/2的WebSocket
        webSocket.Options.HttpVersion = HttpVersion.Version20;
        webSocket.Options.HttpVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
    }
    else
    {
        // HTTP/1.1 WebSocket
        webSocket.Options.HttpVersion = HttpVersion.Version11;
        webSocket.Options.HttpVersionPolicy = HttpVersionPolicy.RequestVersionExact;
    }

    // 设置自定义请求头（仅主连接）
    if (tunnelId == null)
    {
        webSocket.Options.SetRequestHeader("nodeName", tunnel?.Name ?? string.Empty);
        webSocket.Options.SetRequestHeader("token", tunnel?.Token ?? string.Empty);
        webSocket.Options.SetRequestHeader("clientType", "TunnelClient");
        webSocket.Options.SetRequestHeader("requestId", Guid.NewGuid().ToString());
    }

    try
    {
        // 建立WebSocket连接
        await webSocket.ConnectAsync(serverUri, _httpClient, cancellationToken);
        
        // 包装为Stream接口
        return new WebSocketStream(webSocket);
    }
    catch (Exception)
    {
        webSocket.Dispose();
        throw;
    }
}
```

#### 5.2.2 WebSocketStream实现

```csharp
// WebSocketStream将WebSocket包装为Stream接口
public class WebSocketStream : Stream
{
    private readonly WebSocket _webSocket;
    private readonly byte[] _buffer;

    public WebSocketStream(WebSocket webSocket)
    {
        _webSocket = webSocket;
        _buffer = new byte[8192];  // 8KB缓冲区
    }

    public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        var segment = new ArraySegment<byte>(buffer, offset, count);
        var result = await _webSocket.ReceiveAsync(segment, cancellationToken);
        
        if (result.MessageType == WebSocketMessageType.Close)
        {
            return 0;  // 连接关闭
        }
        
        return result.Count;
    }

    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        var segment = new ArraySegment<byte>(buffer, offset, count);
        await _webSocket.SendAsync(segment, WebSocketMessageType.Binary, true, cancellationToken);
    }

    public override void Flush() { }
    public override Task FlushAsync(CancellationToken cancellationToken) => Task.CompletedTask;

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _webSocket?.Dispose();
        }
        base.Dispose(disposing);
    }
}
```

### 5.3 协议选择策略

```csharp
// 在MonitorServer中的协议选择逻辑
private async Task<Stream> HttpConnectServerCoreAsync(Tunnel? tunnel, Guid? tunnelId, CancellationToken cancellationToken)
{
    // 根据配置选择协议
    if (tunnel?.IsHttp2 == true) 
        return await Http20ConnectServerAsync(tunnel, tunnelId, cancellationToken);

    if (tunnel?.IsWebSocket == true)
        return await HttpWebSocketConnectServerAsync(tunnel, tunnelId, cancellationToken);

    Log.UnsupportedConnectionType(_logger, tunnel?.Type);
    throw new NotSupportedException("不支持的连接类型，只支持http2和websocket连接。请检查Tunnel配置。");
}

// 配置文件中的协议指定
{
    "Type": "h2",        // HTTP/2协议
    "Type": "ws",        // WebSocket协议
    "ServerHttp2Support": true  // 服务器HTTP/2支持标志
}
```

## 6. 数据流转详细流程

### 6.1 双向数据复制机制

```csharp
// 核心数据转发实现 - ServerClient.BindTunnelIoAsync
private async void BindTunnelIoAsync(Guid tunnelId, CancellationToken cancellationToken)
{
    var stopwatch = Stopwatch.StartNew();
    try
    {
        // 1. 创建到本地服务的连接
        await using var targetTunnel = await monitorServer.CreateTargetTunnelAsync(tunnel, cancellationToken);

        // 2. 创建到服务器的隧道连接
        await using var serverTunnel = await monitorServer.CreateServerTunnelAsync(tunnel, tunnelId, cancellationToken);

        var count = Interlocked.Increment(ref _tunnelCount);
        logger.LogWarning($"新的隧道id，耗时：{stopwatch.ElapsedMilliseconds}ms 当前数量：{count}");

        // 3. 建立双向数据管道
        //    server -> target: 外部请求数据流向内网服务
        var server2Target = serverTunnel.CopyToAsync(targetTunnel, cancellationToken);
        
        //    target -> server: 内网服务响应数据流向外部
        var target2Server = targetTunnel.CopyToAsync(serverTunnel, cancellationToken);
        
        // 4. 等待任一方向的数据传输完成
        var completedTask = await Task.WhenAny(server2Target, target2Server);
        
        // 当任一方向完成时，隧道关闭
    }
    catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
    {
        logger.LogWarning("隧道被取消");
    }
    catch (Exception ex)
    {
        logger.LogError($"连接异常：{ex.Message}");
    }
    finally
    {
        stopwatch.Stop();
        Interlocked.Decrement(ref _tunnelCount);
        
        // 记录隧道生命周期
        Log.LogTunnelClosed(logger, tunnelId, "target", stopwatch.Elapsed.TotalMilliseconds, _tunnelCount);
    }
}
```

### 6.2 流式数据传输优化

#### 6.2.1 ForceFlushStream - 强制刷新流

```csharp
// 确保数据及时传输的包装流
public class ForceFlushStream : DelegatingStream
{
    public ForceFlushStream(Stream inner) : base(inner) { }

    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        await Inner.WriteAsync(buffer, offset, count, cancellationToken);
        await Inner.FlushAsync(cancellationToken);  // 强制刷新
    }

    public override async ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
    {
        await Inner.WriteAsync(buffer, cancellationToken);
        await Inner.FlushAsync(cancellationToken);  // 强制刷新
    }
}

// 使用ForceFlushStream确保实时性
public async Task<Stream> CreateServerTunnelAsync(Tunnel tunnel, Guid tunnelId, CancellationToken cancellationToken)
{
    var stream = await ConnectServerAsync(tunnel, tunnelId, cancellationToken);
    return new ForceFlushStream(stream);  // 包装为强制刷新流
}
```

#### 6.2.2 SafeWriteStream - 安全写入流

```csharp
// 线程安全的写入流包装
public class SafeWriteStream : DelegatingStream
{
    private readonly SemaphoreSlim _writeSemaphore = new(1, 1);

    public SafeWriteStream(Stream inner) : base(inner) { }

    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        await _writeSemaphore.WaitAsync(cancellationToken);
        try
        {
            await Inner.WriteAsync(buffer, offset, count, cancellationToken);
        }
        finally
        {
            _writeSemaphore.Release();
        }
    }

    public override async ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
    {
        await _writeSemaphore.WaitAsync(cancellationToken);
        try
        {
            await Inner.WriteAsync(buffer, cancellationToken);
        }
        finally
        {
            _writeSemaphore.Release();
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _writeSemaphore?.Dispose();
        }
        base.Dispose(disposing);
    }
}
```

### 6.3 内存优化技术

#### 6.3.1 内存池使用

```csharp
// 在AgentClientConnection中使用内存池
public async Task CreateHttpTunnelAsync(Guid tunnelId, CancellationToken cancellationToken)
{
    const int size = 64;
    var tunnelIdLine = $"{tunnelId}\r\n";

    // 使用共享内存池，减少内存分配
    using var owner = MemoryPool<byte>.Shared.Rent(size);
    var length = Encoding.ASCII.GetBytes(tunnelIdLine, owner.Memory.Span);

    var buffer = owner.Memory[..length];
    await _stream.WriteAsync(buffer, cancellationToken);
}

// 心跳数据的预分配
private static readonly ReadOnlyMemory<byte> PingLine = "PING\r\n"u8.ToArray();
private static readonly ReadOnlyMemory<byte> PongLine = "PONG\r\n"u8.ToArray();

// 直接使用预分配的内存，避免运行时分配
await _stream.WriteAsync(PingLine);
```

#### 6.3.2 流复制优化

```csharp
// Stream.CopyToAsync的默认实现已经进行了优化
// 使用内部缓冲区进行高效的数据复制
public static Task CopyToAsync(this Stream source, Stream destination, CancellationToken cancellationToken)
{
    // .NET内部使用81920字节(80KB)的缓冲区
    // 对于网络流，这个大小在延迟和吞吐量之间提供了良好的平衡
    return source.CopyToAsync(destination, 81920, cancellationToken);
}

// 自定义的高性能复制实现（如需要）
public static async Task CopyToAsync(Stream source, Stream destination, CancellationToken cancellationToken)
{
    using var owner = MemoryPool<byte>.Shared.Rent(65536);  // 64KB缓冲区
    var buffer = owner.Memory;
    
    int bytesRead;
    while ((bytesRead = await source.ReadAsync(buffer, cancellationToken)) > 0)
    {
        await destination.WriteAsync(buffer[..bytesRead], cancellationToken);
    }
}
```

### 6.4 错误处理和连接恢复

```csharp
// 在Worker中的连接恢复逻辑
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    var tunnel = Tunnel.GetTunnel();
    var monitorServer = new MonitorServer(_services);
    var serverClient = new ServerClient(monitorServer, tunnel, _logger);

    // 注册节点
    await monitorServer.RegisterNodeAsync(tunnel, stoppingToken);

    // 主循环：自动重连机制
    while (!stoppingToken.IsCancellationRequested)
    {
        try
        {
            await serverClient.TransportCoreAsync(tunnel, stoppingToken);
        }
        catch (UnauthorizedAccessException e)
        {
            // 认证错误：记录日志并退出
            _logger.LogError(e, "连接被拒绝，请检查Token是否正确或是否过期！");
            Environment.Exit(0);
        }
        catch (Exception e)
        {
            // 其他错误：记录日志并重连
            _logger.LogError(e, "连接错误！");
        }

        // 重连延迟
        _logger.LogInformation("尝试重新连接到服务器...");
        await Task.Delay(tunnel.ReconnectInterval * 1000, stoppingToken);
        _logger.LogInformation("重新连接到服务器中...");
    }
}

// 隧道级别的错误处理
private async void BindTunnelIoAsync(Guid tunnelId, CancellationToken cancellationToken)
{
    try
    {
        // 隧道数据传输逻辑
        // ...
    }
    catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
    {
        // 正常取消操作
        logger.LogWarning("隧道被正常取消");
    }
    catch (SocketException ex)
    {
        // 网络错误
        logger.LogError($"网络错误：{ex.Message}");
    }
    catch (IOException ex)
    {
        // IO错误
        logger.LogError($"IO错误：{ex.Message}");
    }
    catch (Exception ex)
    {
        // 其他未预期错误
        logger.LogError($"未知错误：{ex.Message}");
    }
    finally
    {
        // 确保资源清理
        Interlocked.Decrement(ref _tunnelCount);
    }
}
```

这个详细的技术分析文档涵盖了FastGateway内网穿透系统的所有核心技术细节，包括架构设计、关键组件实现、通信协议、数据流转机制等。文档以技术专家的角度编写，提供了深入的代码分析和实现细节，适合作为技术学习和系统理解的参考资料。