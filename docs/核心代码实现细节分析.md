# FastGateway 核心代码实现细节深度分析

## 目录
- [1. 关键类型和接口设计](#1-关键类型和接口设计)
- [2. 隧道管理核心实现](#2-隧道管理核心实现)
- [3. 网络通信层实现](#3-网络通信层实现)
- [4. 配置管理和热重载](#4-配置管理和热重载)
- [5. 中间件管道设计](#5-中间件管道设计)
- [6. 性能优化实现](#6-性能优化实现)
- [7. 错误处理和日志系统](#7-错误处理和日志系统)
- [8. 安全机制实现](#8-安全机制实现)

## 1. 关键类型和接口设计

### 1.1 传输协议枚举

```csharp
// src/Core/TransportProtocol.cs
/// <summary>
/// 传输协议枚举 - 定义支持的通信协议类型
/// </summary>
public enum TransportProtocol
{
    /// <summary>HTTP/1.1协议</summary>
    Http11,
    
    /// <summary>HTTP/2协议 - 高性能多路复用</summary>
    Http2,
    
    /// <summary>基于HTTP/1.1的WebSocket</summary>
    WebSocketWithHttp11,
    
    /// <summary>基于HTTP/2的WebSocket</summary>
    WebSocketWithHttp2
}
```

### 1.2 核心特性接口

```csharp
// src/FastGateway/Tunnels/IFastFeature.cs
/// <summary>
/// 快速传输特性接口 - 抽象HTTP连接的底层传输能力
/// </summary>
public interface IFastFeature
{
    /// <summary>是否为隧道请求</summary>
    bool IsRequest { get; }
    
    /// <summary>传输协议类型</summary>
    TransportProtocol Protocol { get; }
    
    /// <summary>接受连接为流对象</summary>
    ValueTask<Stream> AcceptAsStreamAsync();
    
    /// <summary>接受连接为安全写入流</summary>
    ValueTask<Stream> AcceptAsSafeWriteStreamAsync();
}

/// <summary>
/// FastFeature实现 - 封装HTTP上下文的传输能力
/// </summary>
public class FastFeature : IFastFeature
{
    private readonly HttpContext _httpContext;

    public FastFeature(HttpContext httpContext)
    {
        _httpContext = httpContext;
    }

    /// <summary>
    /// 判断是否为CONNECT请求（隧道建立请求）
    /// </summary>
    public bool IsRequest => _httpContext.Request.Method == HttpMethods.Connect;

    /// <summary>
    /// 根据HTTP协议版本确定传输协议
    /// </summary>
    public TransportProtocol Protocol
    {
        get
        {
            var protocol = _httpContext.Request.Protocol;
            var isWebSocket = _httpContext.WebSockets.IsWebSocketRequest;
            
            return protocol switch
            {
                "HTTP/1.1" when isWebSocket => TransportProtocol.WebSocketWithHttp11,
                "HTTP/1.1" => TransportProtocol.Http11,
                "HTTP/2" when isWebSocket => TransportProtocol.WebSocketWithHttp2,
                "HTTP/2" => TransportProtocol.Http2,
                _ => TransportProtocol.Http11
            };
        }
    }

    /// <summary>
    /// 接受HTTP连接为流 - 用于HTTP/2双向通信
    /// </summary>
    public async ValueTask<Stream> AcceptAsStreamAsync()
    {
        if (IsRequest)
        {
            // 对于CONNECT请求，设置200状态码并返回双工流
            _httpContext.Response.StatusCode = 200;
            await _httpContext.Response.Body.FlushAsync();
            
            // 返回双工HTTP流，支持读写操作
            return new DuplexHttpStream(_httpContext);
        }
        
        // 普通请求返回请求体流
        return _httpContext.Request.Body;
    }

    /// <summary>
    /// 接受连接为安全写入流 - 包装线程安全的写入操作
    /// </summary>
    public async ValueTask<Stream> AcceptAsSafeWriteStreamAsync()
    {
        var stream = await AcceptAsStreamAsync();
        return new SafeWriteStream(stream);
    }
}
```

### 1.3 双工HTTP流实现

```csharp
// src/FastGateway/Tunnels/DuplexHttpStream.cs
/// <summary>
/// 双工HTTP流 - 将HTTP连接转换为可读写的流对象
/// 用于HTTP/2 CONNECT协议的双向数据传输
/// </summary>
public class DuplexHttpStream : Stream
{
    private readonly HttpContext _httpContext;
    private readonly Stream _requestBody;
    private readonly Stream _responseBody;

    public DuplexHttpStream(HttpContext httpContext)
    {
        _httpContext = httpContext;
        _requestBody = httpContext.Request.Body;
        _responseBody = httpContext.Response.Body;
    }

    public override bool CanRead => _requestBody.CanRead;
    public override bool CanWrite => _responseBody.CanWrite;
    public override bool CanSeek => false;
    public override long Length => throw new NotSupportedException();
    public override long Position 
    { 
        get => throw new NotSupportedException(); 
        set => throw new NotSupportedException(); 
    }

    /// <summary>
    /// 从请求体读取数据
    /// </summary>
    public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        return await _requestBody.ReadAsync(buffer, offset, count, cancellationToken);
    }

    /// <summary>
    /// 向响应体写入数据
    /// </summary>
    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        await _responseBody.WriteAsync(buffer, offset, count, cancellationToken);
    }

    /// <summary>
    /// 刷新响应流
    /// </summary>
    public override async Task FlushAsync(CancellationToken cancellationToken)
    {
        await _responseBody.FlushAsync(cancellationToken);
    }

    // 同步方法实现
    public override int Read(byte[] buffer, int offset, int count)
    {
        return _requestBody.Read(buffer, offset, count);
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
        _responseBody.Write(buffer, offset, count);
    }

    public override void Flush()
    {
        _responseBody.Flush();
    }

    public override long Seek(long offset, SeekOrigin origin)
    {
        throw new NotSupportedException();
    }

    public override void SetLength(long value)
    {
        throw new NotSupportedException();
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            // HTTP上下文会自动处理底层流的释放
        }
        base.Dispose(disposing);
    }
}
```

## 2. 隧道管理核心实现

### 2.1 隧道工厂模式

```csharp
// src/FastGateway/Tunnels/HttpTunnelFactory.cs
/// <summary>
/// HTTP隧道工厂 - 管理隧道的创建、等待和结果设置
/// 使用生产者-消费者模式处理隧道请求
/// </summary>
public class HttpTunnelFactory
{
    // 等待中的隧道请求 - 键为隧道ID，值为完成源
    private readonly ConcurrentDictionary<Guid, TaskCompletionSource<HttpTunnel>> _waitingTunnels = new();
    
    // 隧道超时时间
    private readonly TimeSpan _tunnelTimeout = TimeSpan.FromSeconds(30);

    /// <summary>
    /// 检查隧道是否存在于等待队列中
    /// </summary>
    public bool Contains(Guid tunnelId)
    {
        return _waitingTunnels.ContainsKey(tunnelId);
    }

    /// <summary>
    /// 创建隧道等待任务 - 生产者调用
    /// </summary>
    public async Task<HttpTunnel> CreateTunnelAsync(Guid tunnelId, CancellationToken cancellationToken)
    {
        var tcs = new TaskCompletionSource<HttpTunnel>();
        
        // 添加到等待队列
        if (!_waitingTunnels.TryAdd(tunnelId, tcs))
        {
            throw new InvalidOperationException($"隧道ID {tunnelId} 已存在");
        }

        try
        {
            // 设置超时取消
            using var timeoutCts = new CancellationTokenSource(_tunnelTimeout);
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
            
            // 注册取消回调
            linkedCts.Token.Register(() => 
            {
                if (_waitingTunnels.TryRemove(tunnelId, out var completionSource))
                {
                    completionSource.TrySetCanceled();
                }
            });

            // 等待隧道建立
            return await tcs.Task;
        }
        catch
        {
            // 确保清理等待队列
            _waitingTunnels.TryRemove(tunnelId, out _);
            throw;
        }
    }

    /// <summary>
    /// 设置隧道结果 - 消费者调用
    /// </summary>
    public bool SetResult(HttpTunnel tunnel)
    {
        if (_waitingTunnels.TryRemove(tunnel.Id, out var tcs))
        {
            return tcs.TrySetResult(tunnel);
        }
        return false;
    }

    /// <summary>
    /// 设置隧道异常
    /// </summary>
    public bool SetException(Guid tunnelId, Exception exception)
    {
        if (_waitingTunnels.TryRemove(tunnelId, out var tcs))
        {
            return tcs.TrySetException(exception);
        }
        return false;
    }

    /// <summary>
    /// 获取等待中的隧道数量
    /// </summary>
    public int WaitingCount => _waitingTunnels.Count;
}
```

### 2.2 Agent隧道工厂

```csharp
// src/FastGateway/Tunnels/AgentTunnelFactory.cs
/// <summary>
/// Agent隧道工厂 - 专门处理Agent客户端的隧道管理
/// 集成了客户端连接管理和隧道创建逻辑
/// </summary>
public class AgentTunnelFactory
{
    private readonly HttpTunnelFactory _httpTunnelFactory;
    private readonly AgentClientManager _clientManager;
    private readonly ILogger<AgentTunnelFactory> _logger;

    public AgentTunnelFactory(
        HttpTunnelFactory httpTunnelFactory,
        AgentClientManager clientManager,
        ILogger<AgentTunnelFactory> logger)
    {
        _httpTunnelFactory = httpTunnelFactory;
        _clientManager = clientManager;
        _logger = logger;
    }

    /// <summary>
    /// 为指定代理创建隧道
    /// </summary>
    public async Task<HttpTunnel> CreateTunnelForProxyAsync(string proxyId, CancellationToken cancellationToken)
    {
        // 生成隧道ID
        var tunnelId = Guid.NewGuid();
        
        // 查找对应的客户端连接
        var client = await _clientManager.FindClientForProxyAsync(proxyId);
        if (client == null)
        {
            throw new InvalidOperationException($"未找到代理 {proxyId} 对应的客户端");
        }

        // 通知客户端创建隧道
        await client.Connection.CreateHttpTunnelAsync(tunnelId, cancellationToken);
        
        // 增加隧道计数
        var tunnelCount = client.Connection.IncrementHttpTunnelCount();
        
        Log.LogTunnelCreated(_logger, client.Id, tunnelId, tunnelCount);

        // 等待隧道建立
        var tunnel = await _httpTunnelFactory.CreateTunnelAsync(tunnelId, cancellationToken);
        
        // 绑定隧道到客户端连接
        tunnel.BindConnection(client.Connection);
        
        return tunnel;
    }

    /// <summary>
    /// 检查隧道是否存在
    /// </summary>
    public bool Contains(Guid tunnelId) => _httpTunnelFactory.Contains(tunnelId);

    /// <summary>
    /// 设置隧道结果
    /// </summary>
    public bool SetResult(HttpTunnel tunnel) => _httpTunnelFactory.SetResult(tunnel);

    private static partial class Log
    {
        [LoggerMessage(LogLevel.Information, 
            "[{clientId}] 创建隧道 {tunnelId}，当前隧道数量: {tunnelCount}")]
        public static partial void LogTunnelCreated(ILogger logger, string clientId, Guid tunnelId, int tunnelCount);
    }
}
```

### 2.3 客户端管理器

```csharp
// src/FastGateway/Tunnels/AgentClientManager.cs
/// <summary>
/// Agent客户端管理器 - 管理所有连接的客户端
/// 提供客户端的添加、移除、查找等功能
/// </summary>
public class AgentClientManager
{
    // 客户端集合 - 线程安全的并发字典
    private readonly ConcurrentDictionary<string, AgentClient> _clients = new();
    
    // 代理ID到客户端的映射 - 快速查找代理对应的客户端
    private readonly ConcurrentDictionary<string, string> _proxyToClient = new();
    
    private readonly ILogger<AgentClientManager> _logger;
    private readonly TunnelClientProxy _tunnelClientProxy;

    public AgentClientManager(ILogger<AgentClientManager> logger, TunnelClientProxy tunnelClientProxy)
    {
        _logger = logger;
        _tunnelClientProxy = tunnelClientProxy;
    }

    /// <summary>
    /// 添加客户端
    /// </summary>
    public async Task<bool> AddAsync(AgentClient client, CancellationToken cancellationToken)
    {
        if (_clients.TryAdd(client.Id, client))
        {
            Log.LogClientConnected(_logger, client.Id, client.Protocol, client.RemoteEndpoint);
            
            // 更新代理映射
            await UpdateProxyMappingsAsync(client);
            
            return true;
        }
        
        Log.LogClientAddFailed(_logger, client.Id);
        return false;
    }

    /// <summary>
    /// 移除客户端
    /// </summary>
    public async Task<bool> RemoveAsync(AgentClient client, CancellationToken cancellationToken)
    {
        if (_clients.TryRemove(client.Id, out var removedClient))
        {
            var connectionTime = DateTimeOffset.Now - removedClient.CreationTime;
            Log.LogClientDisconnected(_logger, client.Id, connectionTime, removedClient.HttpTunnelCount);
            
            // 清理代理映射
            await CleanupProxyMappingsAsync(client);
            
            return true;
        }
        
        return false;
    }

    /// <summary>
    /// 根据代理ID查找客户端
    /// </summary>
    public async Task<AgentClient?> FindClientForProxyAsync(string proxyId)
    {
        if (_proxyToClient.TryGetValue(proxyId, out var clientId))
        {
            _clients.TryGetValue(clientId, out var client);
            return client;
        }
        
        return null;
    }

    /// <summary>
    /// 获取所有活跃客户端
    /// </summary>
    public IEnumerable<AgentClient> GetActiveClients()
    {
        return _clients.Values;
    }

    /// <summary>
    /// 获取客户端统计信息
    /// </summary>
    public ClientStatistics GetStatistics()
    {
        var clients = _clients.Values;
        return new ClientStatistics
        {
            TotalClients = clients.Count(),
            TotalTunnels = clients.Sum(c => c.HttpTunnelCount),
            ProtocolDistribution = clients.GroupBy(c => c.Protocol)
                                         .ToDictionary(g => g.Key, g => g.Count()),
            AverageConnectionTime = clients.Any() 
                ? clients.Average(c => (DateTimeOffset.Now - c.CreationTime).TotalMinutes)
                : 0
        };
    }

    /// <summary>
    /// 更新代理映射
    /// </summary>
    private async Task UpdateProxyMappingsAsync(AgentClient client)
    {
        var tunnels = _tunnelClientProxy.GetAllClients();
        var clientTunnel = tunnels.FirstOrDefault(t => t.Name == client.Id.Replace("node_", ""));
        
        if (clientTunnel != null)
        {
            foreach (var proxy in clientTunnel.Proxy)
            {
                _proxyToClient.TryAdd(proxy.Id, client.Id);
            }
        }
    }

    /// <summary>
    /// 清理代理映射
    /// </summary>
    private async Task CleanupProxyMappingsAsync(AgentClient client)
    {
        var keysToRemove = _proxyToClient.Where(kvp => kvp.Value == client.Id)
                                       .Select(kvp => kvp.Key)
                                       .ToList();
        
        foreach (var key in keysToRemove)
        {
            _proxyToClient.TryRemove(key, out _);
        }
    }

    private static partial class Log
    {
        [LoggerMessage(LogLevel.Information, 
            "[{clientId}] 客户端已连接，协议: {protocol}，地址: {endpoint}")]
        public static partial void LogClientConnected(ILogger logger, string clientId, 
            TransportProtocol protocol, IPEndPoint? endpoint);

        [LoggerMessage(LogLevel.Information, 
            "[{clientId}] 客户端已断开，连接时长: {connectionTime}，隧道数: {tunnelCount}")]
        public static partial void LogClientDisconnected(ILogger logger, string clientId, 
            TimeSpan connectionTime, int tunnelCount);

        [LoggerMessage(LogLevel.Warning, 
            "[{clientId}] 客户端添加失败，ID可能已存在")]
        public static partial void LogClientAddFailed(ILogger logger, string clientId);
    }
}

/// <summary>
/// 客户端统计信息
/// </summary>
public class ClientStatistics
{
    public int TotalClients { get; set; }
    public int TotalTunnels { get; set; }
    public Dictionary<TransportProtocol, int> ProtocolDistribution { get; set; } = new();
    public double AverageConnectionTime { get; set; }
}
```

## 3. 网络通信层实现

### 3.1 连接配置类

```csharp
// src/FastGateway/Tunnels/ConnectionConfig.cs
/// <summary>
/// 连接配置 - 定义连接的各种参数
/// </summary>
public class ConnectionConfig
{
    /// <summary>是否启用心跳</summary>
    public bool KeepAlive { get; set; } = true;
    
    /// <summary>心跳间隔</summary>
    public TimeSpan KeepAliveInterval { get; set; } = TimeSpan.FromSeconds(30);
    
    /// <summary>连接超时时间</summary>
    public TimeSpan ConnectionTimeout { get; set; } = TimeSpan.FromSeconds(60);
    
    /// <summary>读取缓冲区大小</summary>
    public int ReadBufferSize { get; set; } = 8192;
    
    /// <summary>写入缓冲区大小</summary>
    public int WriteBufferSize { get; set; } = 8192;
    
    /// <summary>最大重连次数</summary>
    public int MaxRetryCount { get; set; } = 3;
    
    /// <summary>重连间隔</summary>
    public TimeSpan RetryInterval { get; set; } = TimeSpan.FromSeconds(5);

    /// <summary>
    /// 创建默认配置
    /// </summary>
    public static ConnectionConfig Default => new();

    /// <summary>
    /// 创建高性能配置
    /// </summary>
    public static ConnectionConfig HighPerformance => new()
    {
        KeepAliveInterval = TimeSpan.FromSeconds(15),
        ReadBufferSize = 65536,   // 64KB
        WriteBufferSize = 65536,  // 64KB
        ConnectionTimeout = TimeSpan.FromSeconds(30)
    };

    /// <summary>
    /// 创建低延迟配置
    /// </summary>
    public static ConnectionConfig LowLatency => new()
    {
        KeepAliveInterval = TimeSpan.FromSeconds(10),
        ReadBufferSize = 4096,    // 4KB
        WriteBufferSize = 4096,   // 4KB
        ConnectionTimeout = TimeSpan.FromSeconds(15)
    };

    /// <summary>
    /// 验证配置有效性
    /// </summary>
    public void Validate()
    {
        if (KeepAliveInterval <= TimeSpan.Zero)
            throw new ArgumentException("心跳间隔必须大于零");
            
        if (ConnectionTimeout <= TimeSpan.Zero)
            throw new ArgumentException("连接超时时间必须大于零");
            
        if (ReadBufferSize <= 0)
            throw new ArgumentException("读取缓冲区大小必须大于零");
            
        if (WriteBufferSize <= 0)
            throw new ArgumentException("写入缓冲区大小必须大于零");
            
        if (MaxRetryCount < 0)
            throw new ArgumentException("最大重连次数不能为负数");
    }
}
```

### 3.2 WebSocket流实现

```csharp
// src/Core/WebSocketStream.cs
/// <summary>
/// WebSocket流包装器 - 将WebSocket转换为Stream接口
/// 支持二进制数据的双向传输
/// </summary>
public class WebSocketStream : Stream
{
    private readonly WebSocket _webSocket;
    private readonly SemaphoreSlim _sendLock = new(1, 1);
    private volatile bool _disposed;

    public WebSocketStream(WebSocket webSocket)
    {
        _webSocket = webSocket ?? throw new ArgumentNullException(nameof(webSocket));
    }

    public override bool CanRead => !_disposed && _webSocket.State == WebSocketState.Open;
    public override bool CanWrite => !_disposed && _webSocket.State == WebSocketState.Open;
    public override bool CanSeek => false;
    public override long Length => throw new NotSupportedException();
    public override long Position 
    { 
        get => throw new NotSupportedException(); 
        set => throw new NotSupportedException(); 
    }

    /// <summary>
    /// 异步读取数据
    /// </summary>
    public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        ThrowIfDisposed();
        
        if (buffer == null) throw new ArgumentNullException(nameof(buffer));
        if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
        if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
        if (offset + count > buffer.Length) throw new ArgumentException("缓冲区越界");

        if (_webSocket.State != WebSocketState.Open)
            return 0;

        try
        {
            var segment = new ArraySegment<byte>(buffer, offset, count);
            var result = await _webSocket.ReceiveAsync(segment, cancellationToken);
            
            // 处理不同的消息类型
            switch (result.MessageType)
            {
                case WebSocketMessageType.Binary:
                    return result.Count;
                    
                case WebSocketMessageType.Text:
                    // 文本消息当作二进制处理
                    return result.Count;
                    
                case WebSocketMessageType.Close:
                    return 0;
                    
                default:
                    return 0;
            }
        }
        catch (WebSocketException ex) when (ex.WebSocketErrorCode == WebSocketError.ConnectionClosedPrematurely)
        {
            return 0;
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            return 0;
        }
    }

    /// <summary>
    /// 异步写入数据
    /// </summary>
    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        ThrowIfDisposed();
        
        if (buffer == null) throw new ArgumentNullException(nameof(buffer));
        if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
        if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
        if (offset + count > buffer.Length) throw new ArgumentException("缓冲区越界");

        if (_webSocket.State != WebSocketState.Open || count == 0)
            return;

        // 使用信号量确保写入操作的线程安全
        await _sendLock.WaitAsync(cancellationToken);
        try
        {
            var segment = new ArraySegment<byte>(buffer, offset, count);
            await _webSocket.SendAsync(segment, WebSocketMessageType.Binary, true, cancellationToken);
        }
        finally
        {
            _sendLock.Release();
        }
    }

    /// <summary>
    /// 同步读取 - 不推荐使用
    /// </summary>
    public override int Read(byte[] buffer, int offset, int count)
    {
        // 同步版本会阻塞线程，不推荐在高并发场景使用
        return ReadAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
    }

    /// <summary>
    /// 同步写入 - 不推荐使用
    /// </summary>
    public override void Write(byte[] buffer, int offset, int count)
    {
        WriteAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
    }

    public override void Flush() { }
    public override Task FlushAsync(CancellationToken cancellationToken) => Task.CompletedTask;

    public override long Seek(long offset, SeekOrigin origin)
    {
        throw new NotSupportedException();
    }

    public override void SetLength(long value)
    {
        throw new NotSupportedException();
    }

    /// <summary>
    /// 释放资源
    /// </summary>
    protected override void Dispose(bool disposing)
    {
        if (disposing && !_disposed)
        {
            _disposed = true;
            _sendLock?.Dispose();
            
            if (_webSocket.State == WebSocketState.Open)
            {
                try
                {
                    _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Stream disposed", CancellationToken.None)
                             .ConfigureAwait(false)
                             .GetAwaiter()
                             .GetResult();
                }
                catch
                {
                    // 忽略关闭时的异常
                }
            }
            
            _webSocket?.Dispose();
        }
        
        base.Dispose(disposing);
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(WebSocketStream));
    }
}
```

### 3.3 安全写入流

```csharp
// src/Core/SafeWriteStream.cs
/// <summary>
/// 安全写入流 - 确保写入操作的线程安全
/// 在多线程环境下防止写入竞态条件
/// </summary>
public class SafeWriteStream : DelegatingStream
{
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private volatile bool _disposed;

    public SafeWriteStream(Stream inner) : base(inner)
    {
    }

    /// <summary>
    /// 线程安全的异步写入
    /// </summary>
    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        ThrowIfDisposed();
        
        await _writeLock.WaitAsync(cancellationToken);
        try
        {
            await Inner.WriteAsync(buffer, offset, count, cancellationToken);
        }
        finally
        {
            _writeLock.Release();
        }
    }

    /// <summary>
    /// 线程安全的异步写入（Memory版本）
    /// </summary>
    public override async ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        
        await _writeLock.WaitAsync(cancellationToken);
        try
        {
            await Inner.WriteAsync(buffer, cancellationToken);
        }
        finally
        {
            _writeLock.Release();
        }
    }

    /// <summary>
    /// 线程安全的同步写入
    /// </summary>
    public override void Write(byte[] buffer, int offset, int count)
    {
        ThrowIfDisposed();
        
        _writeLock.Wait();
        try
        {
            Inner.Write(buffer, offset, count);
        }
        finally
        {
            _writeLock.Release();
        }
    }

    /// <summary>
    /// 线程安全的刷新
    /// </summary>
    public override async Task FlushAsync(CancellationToken cancellationToken)
    {
        ThrowIfDisposed();
        
        await _writeLock.WaitAsync(cancellationToken);
        try
        {
            await Inner.FlushAsync(cancellationToken);
        }
        finally
        {
            _writeLock.Release();
        }
    }

    /// <summary>
    /// 读取操作不需要锁保护
    /// </summary>
    public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        ThrowIfDisposed();
        return await Inner.ReadAsync(buffer, offset, count, cancellationToken);
    }

    /// <summary>
    /// 读取操作不需要锁保护（Memory版本）
    /// </summary>
    public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        return await Inner.ReadAsync(buffer, cancellationToken);
    }

    /// <summary>
    /// 释放资源
    /// </summary>
    protected override void Dispose(bool disposing)
    {
        if (disposing && !_disposed)
        {
            _disposed = true;
            _writeLock?.Dispose();
        }
        
        base.Dispose(disposing);
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(SafeWriteStream));
    }
}
```

## 4. 配置管理和热重载

### 4.1 配置服务实现

```csharp
// src/FastGateway/Services/ConfigurationService.cs
/// <summary>
/// 配置服务 - 替代EntityFramework的轻量级配置管理
/// 支持JSON文件存储和热重载
/// </summary>
public class ConfigurationService
{
    private readonly string _configPath;
    private readonly ILogger<ConfigurationService> _logger;
    private readonly FileSystemWatcher _fileWatcher;
    private readonly ReaderWriterLockSlim _lock = new();
    
    // 配置缓存
    private AppConfiguration _configuration;

    public ConfigurationService(ILogger<ConfigurationService> logger)
    {
        _logger = logger;
        _configPath = Path.Combine(AppContext.BaseDirectory, "config.json");
        
        // 初始化配置
        LoadConfiguration();
        
        // 设置文件监控
        SetupFileWatcher();
    }

    /// <summary>
    /// 获取所有服务器配置
    /// </summary>
    public List<Server> GetServers()
    {
        _lock.EnterReadLock();
        try
        {
            return _configuration.Servers.ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    /// <summary>
    /// 根据服务器ID获取域名配置
    /// </summary>
    public DomainName[] GetDomainNamesByServerId(string serverId)
    {
        _lock.EnterReadLock();
        try
        {
            return _configuration.DomainNames
                .Where(d => d.ServerId == serverId)
                .ToArray();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    /// <summary>
    /// 获取活跃的证书配置
    /// </summary>
    public List<Cert> GetActiveCerts()
    {
        _lock.EnterReadLock();
        try
        {
            return _configuration.Certificates
                .Where(c => c.IsActive)
                .ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    /// <summary>
    /// 获取黑白名单配置
    /// </summary>
    public List<BlacklistAndWhitelist> GetBlacklistAndWhitelists()
    {
        _lock.EnterReadLock();
        try
        {
            return _configuration.AccessControls.ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    /// <summary>
    /// 获取限流配置
    /// </summary>
    public List<RateLimit> GetRateLimits()
    {
        _lock.EnterReadLock();
        try
        {
            return _configuration.RateLimits.ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    /// <summary>
    /// 更新服务器配置
    /// </summary>
    public async Task UpdateServerAsync(Server server)
    {
        _lock.EnterWriteLock();
        try
        {
            var existingIndex = _configuration.Servers.FindIndex(s => s.Id == server.Id);
            if (existingIndex >= 0)
            {
                _configuration.Servers[existingIndex] = server;
            }
            else
            {
                _configuration.Servers.Add(server);
            }

            await SaveConfigurationAsync();
            
            // 触发配置变更事件
            OnConfigurationChanged?.Invoke(new ConfigurationChangedEventArgs
            {
                ChangeType = ConfigurationChangeType.ServerUpdated,
                EntityId = server.Id
            });
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    /// <summary>
    /// 加载配置文件
    /// </summary>
    private void LoadConfiguration()
    {
        try
        {
            if (File.Exists(_configPath))
            {
                var json = File.ReadAllText(_configPath);
                _configuration = JsonSerializer.Deserialize<AppConfiguration>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true,
                    ReadCommentHandling = JsonCommentHandling.Skip
                }) ?? new AppConfiguration();
            }
            else
            {
                _configuration = new AppConfiguration();
                SaveConfigurationAsync().Wait();
            }

            Log.LogConfigurationLoaded(_logger, _configPath);
        }
        catch (Exception ex)
        {
            Log.LogConfigurationLoadFailed(_logger, _configPath, ex.Message);
            _configuration = new AppConfiguration();
        }
    }

    /// <summary>
    /// 保存配置文件
    /// </summary>
    private async Task SaveConfigurationAsync()
    {
        try
        {
            var json = JsonSerializer.Serialize(_configuration, new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            await File.WriteAllTextAsync(_configPath, json);
            Log.LogConfigurationSaved(_logger, _configPath);
        }
        catch (Exception ex)
        {
            Log.LogConfigurationSaveFailed(_logger, _configPath, ex.Message);
        }
    }

    /// <summary>
    /// 设置文件监控
    /// </summary>
    private void SetupFileWatcher()
    {
        try
        {
            var directory = Path.GetDirectoryName(_configPath);
            var fileName = Path.GetFileName(_configPath);

            _fileWatcher = new FileSystemWatcher(directory!, fileName)
            {
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size
            };

            _fileWatcher.Changed += OnConfigFileChanged;
            _fileWatcher.EnableRaisingEvents = true;

            Log.LogFileWatcherStarted(_logger, _configPath);
        }
        catch (Exception ex)
        {
            Log.LogFileWatcherFailed(_logger, ex.Message);
        }
    }

    /// <summary>
    /// 配置文件变更处理
    /// </summary>
    private async void OnConfigFileChanged(object sender, FileSystemEventArgs e)
    {
        try
        {
            // 延迟一下避免文件正在写入
            await Task.Delay(500);
            
            LoadConfiguration();
            
            OnConfigurationChanged?.Invoke(new ConfigurationChangedEventArgs
            {
                ChangeType = ConfigurationChangeType.FileChanged,
                EntityId = null
            });

            Log.LogConfigurationReloaded(_logger);
        }
        catch (Exception ex)
        {
            Log.LogConfigurationReloadFailed(_logger, ex.Message);
        }
    }

    /// <summary>
    /// 配置变更事件
    /// </summary>
    public event Action<ConfigurationChangedEventArgs>? OnConfigurationChanged;

    public void Dispose()
    {
        _fileWatcher?.Dispose();
        _lock?.Dispose();
    }

    private static partial class Log
    {
        [LoggerMessage(LogLevel.Information, "配置文件已加载: {path}")]
        public static partial void LogConfigurationLoaded(ILogger logger, string path);

        [LoggerMessage(LogLevel.Error, "配置文件加载失败: {path}, 错误: {error}")]
        public static partial void LogConfigurationLoadFailed(ILogger logger, string path, string error);

        [LoggerMessage(LogLevel.Information, "配置文件已保存: {path}")]
        public static partial void LogConfigurationSaved(ILogger logger, string path);

        [LoggerMessage(LogLevel.Error, "配置文件保存失败: {path}, 错误: {error}")]
        public static partial void LogConfigurationSaveFailed(ILogger logger, string path, string error);

        [LoggerMessage(LogLevel.Information, "文件监控已启动: {path}")]
        public static partial void LogFileWatcherStarted(ILogger logger, string path);

        [LoggerMessage(LogLevel.Error, "文件监控启动失败: {error}")]
        public static partial void LogFileWatcherFailed(ILogger logger, string error);

        [LoggerMessage(LogLevel.Information, "配置文件已重新加载")]
        public static partial void LogConfigurationReloaded(ILogger logger);

        [LoggerMessage(LogLevel.Error, "配置文件重新加载失败: {error}")]
        public static partial void LogConfigurationReloadFailed(ILogger logger, string error);
    }
}

/// <summary>
/// 应用配置模型
/// </summary>
public class AppConfiguration
{
    public List<Server> Servers { get; set; } = new();
    public List<DomainName> DomainNames { get; set; } = new();
    public List<Cert> Certificates { get; set; } = new();
    public List<BlacklistAndWhitelist> AccessControls { get; set; } = new();
    public List<RateLimit> RateLimits { get; set; } = new();
    public Dictionary<string, object> Settings { get; set; } = new();
}

/// <summary>
/// 配置变更事件参数
/// </summary>
public class ConfigurationChangedEventArgs
{
    public ConfigurationChangeType ChangeType { get; set; }
    public string? EntityId { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// 配置变更类型
/// </summary>
public enum ConfigurationChangeType
{
    FileChanged,
    ServerUpdated,
    DomainUpdated,
    CertificateUpdated,
    AccessControlUpdated,
    RateLimitUpdated
}
```

## 5. 中间件管道设计

### 5.1 限流中间件

```csharp
// src/FastGateway/Infrastructure/RateLimitMiddleware.cs
/// <summary>
/// 限流中间件 - 实现基于滑动窗口的请求限流
/// 支持IP级别和全局级别的流量控制
/// </summary>
public class RateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RateLimitMiddleware> _logger;
    private readonly List<RateLimit> _rateLimits;
    
    // 滑动窗口存储 - IP -> 时间戳列表
    private readonly ConcurrentDictionary<string, Queue<DateTime>> _requestWindows = new();
    
    // 全局计数器
    private readonly ConcurrentDictionary<string, AtomicCounter> _globalCounters = new();

    public RateLimitMiddleware(RequestDelegate next, ILogger<RateLimitMiddleware> logger, List<RateLimit> rateLimits)
    {
        _next = next;
        _logger = logger;
        _rateLimits = rateLimits;
        
        // 启动清理任务
        _ = Task.Run(CleanupExpiredWindows);
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var clientIp = GetClientIpAddress(context);
        var path = context.Request.Path.Value;
        
        // 查找匹配的限流规则
        var applicableRules = _rateLimits.Where(rl => IsRuleApplicable(rl, path, clientIp)).ToList();
        
        if (applicableRules.Any())
        {
            foreach (var rule in applicableRules)
            {
                if (!await CheckRateLimitAsync(rule, clientIp, context))
                {
                    return; // 请求被限流，已返回429状态码
                }
            }
        }

        await _next(context);
    }

    /// <summary>
    /// 检查限流规则
    /// </summary>
    private async Task<bool> CheckRateLimitAsync(RateLimit rateLimit, string clientIp, HttpContext context)
    {
        var key = GetRateLimitKey(rateLimit, clientIp);
        var now = DateTime.UtcNow;
        
        switch (rateLimit.Type)
        {
            case RateLimitType.SlidingWindow:
                return await CheckSlidingWindowAsync(key, rateLimit, now, context);
                
            case RateLimitType.FixedWindow:
                return await CheckFixedWindowAsync(key, rateLimit, now, context);
                
            case RateLimitType.TokenBucket:
                return await CheckTokenBucketAsync(key, rateLimit, now, context);
                
            default:
                return true;
        }
    }

    /// <summary>
    /// 滑动窗口算法
    /// </summary>
    private async Task<bool> CheckSlidingWindowAsync(string key, RateLimit rateLimit, DateTime now, HttpContext context)
    {
        var window = _requestWindows.GetOrAdd(key, _ => new Queue<DateTime>());
        
        lock (window)
        {
            // 清理过期的请求记录
            var windowStart = now.AddSeconds(-rateLimit.WindowSizeSeconds);
            while (window.Count > 0 && window.Peek() < windowStart)
            {
                window.Dequeue();
            }
            
            // 检查是否超过限制
            if (window.Count >= rateLimit.MaxRequests)
            {
                Log.LogRateLimitExceeded(_logger, key, window.Count, rateLimit.MaxRequests);
                return await HandleRateLimitExceeded(context, rateLimit);
            }
            
            // 记录当前请求
            window.Enqueue(now);
            return true;
        }
    }

    /// <summary>
    /// 固定窗口算法
    /// </summary>
    private async Task<bool> CheckFixedWindowAsync(string key, RateLimit rateLimit, DateTime now, HttpContext context)
    {
        var windowKey = $"{key}:{GetWindowKey(now, rateLimit.WindowSizeSeconds)}";
        var counter = _globalCounters.GetOrAdd(windowKey, _ => new AtomicCounter());
        
        var currentCount = counter.Increment();
        
        if (currentCount > rateLimit.MaxRequests)
        {
            Log.LogRateLimitExceeded(_logger, key, currentCount, rateLimit.MaxRequests);
            return await HandleRateLimitExceeded(context, rateLimit);
        }
        
        return true;
    }

    /// <summary>
    /// 令牌桶算法
    /// </summary>
    private async Task<bool> CheckTokenBucketAsync(string key, RateLimit rateLimit, DateTime now, HttpContext context)
    {
        // 令牌桶实现会更复杂，这里简化为固定窗口
        return await CheckFixedWindowAsync(key, rateLimit, now, context);
    }

    /// <summary>
    /// 处理限流超出
    /// </summary>
    private async Task<bool> HandleRateLimitExceeded(HttpContext context, RateLimit rateLimit)
    {
        context.Response.StatusCode = 429; // Too Many Requests
        context.Response.Headers.Add("Retry-After", rateLimit.WindowSizeSeconds.ToString());
        context.Response.Headers.Add("X-RateLimit-Limit", rateLimit.MaxRequests.ToString());
        context.Response.Headers.Add("X-RateLimit-Window", rateLimit.WindowSizeSeconds.ToString());
        
        await context.Response.WriteAsJsonAsync(new
        {
            error = "Rate limit exceeded",
            message = $"Too many requests. Limit: {rateLimit.MaxRequests} requests per {rateLimit.WindowSizeSeconds} seconds",
            retryAfter = rateLimit.WindowSizeSeconds
        });
        
        return false;
    }

    /// <summary>
    /// 获取客户端IP地址
    /// </summary>
    private string GetClientIpAddress(HttpContext context)
    {
        // 检查X-Forwarded-For头
        if (context.Request.Headers.TryGetValue("X-Forwarded-For", out var forwardedFor))
        {
            var ip = forwardedFor.FirstOrDefault()?.Split(',').FirstOrDefault()?.Trim();
            if (!string.IsNullOrEmpty(ip))
                return ip;
        }
        
        // 检查X-Real-IP头
        if (context.Request.Headers.TryGetValue("X-Real-IP", out var realIp))
        {
            var ip = realIp.FirstOrDefault();
            if (!string.IsNullOrEmpty(ip))
                return ip;
        }
        
        // 使用连接的远程IP
        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }

    /// <summary>
    /// 检查规则是否适用
    /// </summary>
    private bool IsRuleApplicable(RateLimit rateLimit, string? path, string clientIp)
    {
        // 检查路径匹配
        if (!string.IsNullOrEmpty(rateLimit.PathPattern))
        {
            if (!MatchesPattern(path, rateLimit.PathPattern))
                return false;
        }
        
        // 检查IP匹配
        if (!string.IsNullOrEmpty(rateLimit.IpPattern))
        {
            if (!MatchesPattern(clientIp, rateLimit.IpPattern))
                return false;
        }
        
        return true;
    }

    /// <summary>
    /// 模式匹配
    /// </summary>
    private bool MatchesPattern(string? value, string pattern)
    {
        if (string.IsNullOrEmpty(value) || string.IsNullOrEmpty(pattern))
            return false;
            
        // 简单的通配符匹配
        if (pattern == "*")
            return true;
            
        if (pattern.EndsWith("*"))
        {
            var prefix = pattern[..^1];
            return value.StartsWith(prefix, StringComparison.OrdinalIgnoreCase);
        }
        
        if (pattern.StartsWith("*"))
        {
            var suffix = pattern[1..];
            return value.EndsWith(suffix, StringComparison.OrdinalIgnoreCase);
        }
        
        return string.Equals(value, pattern, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// 获取限流键
    /// </summary>
    private string GetRateLimitKey(RateLimit rateLimit, string clientIp)
    {
        return rateLimit.Scope switch
        {
            RateLimitScope.Global => $"global:{rateLimit.Id}",
            RateLimitScope.PerIp => $"ip:{clientIp}:{rateLimit.Id}",
            _ => $"unknown:{rateLimit.Id}"
        };
    }

    /// <summary>
    /// 获取窗口键
    /// </summary>
    private long GetWindowKey(DateTime now, int windowSizeSeconds)
    {
        return (long)(now.Subtract(DateTime.UnixEpoch).TotalSeconds / windowSizeSeconds);
    }

    /// <summary>
    /// 清理过期的窗口数据
    /// </summary>
    private async Task CleanupExpiredWindows()
    {
        while (true)
        {
            await Task.Delay(TimeSpan.FromMinutes(1)); // 每分钟清理一次
            
            try
            {
                var now = DateTime.UtcNow;
                var keysToRemove = new List<string>();
                
                foreach (var kvp in _requestWindows)
                {
                    var window = kvp.Value;
                    lock (window)
                    {
                        if (window.Count == 0 || 
                            (window.Count > 0 && now.Subtract(window.Peek()).TotalMinutes > 10))
                        {
                            keysToRemove.Add(kvp.Key);
                        }
                    }
                }
                
                foreach (var key in keysToRemove)
                {
                    _requestWindows.TryRemove(key, out _);
                }
                
                // 清理全局计数器
                var counterKeysToRemove = _globalCounters.Keys
                    .Where(key => key.Contains(':') && 
                           long.TryParse(key.Split(':').Last(), out var windowKey) &&
                           (now.Subtract(DateTime.UnixEpoch).TotalSeconds / 60) - windowKey > 10)
                    .ToList();
                
                foreach (var key in counterKeysToRemove)
                {
                    _globalCounters.TryRemove(key, out _);
                }
                
                if (keysToRemove.Count > 0 || counterKeysToRemove.Count > 0)
                {
                    Log.LogCleanupCompleted(_logger, keysToRemove.Count, counterKeysToRemove.Count);
                }
            }
            catch (Exception ex)
            {
                Log.LogCleanupFailed(_logger, ex.Message);
            }
        }
    }

    private static partial class Log
    {
        [LoggerMessage(LogLevel.Warning, 
            "限流触发 - Key: {key}, 当前请求数: {current}, 限制: {limit}")]
        public static partial void LogRateLimitExceeded(ILogger logger, string key, int current, int limit);

        [LoggerMessage(LogLevel.Debug, 
            "限流清理完成 - 窗口: {windowCount}, 计数器: {counterCount}")]
        public static partial void LogCleanupCompleted(ILogger logger, int windowCount, int counterCount);

        [LoggerMessage(LogLevel.Error, 
            "限流清理失败: {error}")]
        public static partial void LogCleanupFailed(ILogger logger, string error);
    }
}

/// <summary>
/// 原子计数器
/// </summary>
public class AtomicCounter
{
    private long _value;

    public long Increment() => Interlocked.Increment(ref _value);
    public long Decrement() => Interlocked.Decrement(ref _value);
    public long Value => Interlocked.Read(ref _value);
}

/// <summary>
/// 限流类型
/// </summary>
public enum RateLimitType
{
    SlidingWindow,
    FixedWindow,
    TokenBucket
}

/// <summary>
/// 限流作用域
/// </summary>
public enum RateLimitScope
{
    Global,
    PerIp
}
```

这个详细的核心代码实现分析文档深入展示了FastGateway系统的关键技术实现，包括类型设计、隧道管理、网络通信、配置管理和中间件设计等方面的具体代码实现和技术细节。